@page "/towerdef"
@layout Arcade.Components.Layout.EmptyLayout
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IDisposable

<div class="tower-defense-performance">
    <div class="top-bar">
        <div class="game-title">🏰 Tower Defense</div>
        <div class="stats-compact">
            <span class="stat">💰 @_gold</span>
            <span class="stat">❤️ @_lives</span>
            <span class="stat">🌊 Wave @_currentWave</span>
            <span class="stat">👹 @_enemies.Count</span>
            <span class="stat">💀 @_totalEnemiesKilled</span>
        </div>
        <button class="btn-primary" @onclick="StartNextWave" disabled="@(_gameOver || _isPaused)">
            ▶️ Wave @(_nextWaveNumber)
        </button>
        <button class="btn-toggle @(_autoWave ? "active" : "")" @onclick="ToggleAutoWave">
            🔁 Auto
        </button>
        <button class="btn-toggle @(_showTowerRanges ? "active" : "")" @onclick="ToggleTowerRanges">
            📡 Range
        </button>
        <button class="btn-small" @onclick="TogglePause">@(_isPaused ? "▶️" : "⏸️")</button>
        <button class="btn-small btn" @onclick="ToggleSpeed">⚡ x@_gameSpeed.ToString("0.0")</button>
    </div>

    <div class="game-layout">
        <div class="side-panel left-panel">
            <div class="panel-header">
                <h3>🔧 Upgrade</h3>
            </div>
            @if (_selectedTowerForUpgrade != null)
            {
                <div class="upgrade-content">
                    <div class="tower-icon-large">@GetTowerEmoji(_selectedTowerForUpgrade.Type)</div>
                    <h4>@GetTowerName(_selectedTowerForUpgrade.Type)</h4>

                    <div class="stat-grid">
                        <div class="stat-item">
                            <span>Level</span>
                            <strong>@_selectedTowerForUpgrade.Level</strong>
                        </div>
                        <div class="stat-item">
                            <span>Damage</span>
                            <strong>@((int)(_selectedTowerForUpgrade.Damage * (1 + (_selectedTowerForUpgrade.Level - 1) * 0.5f)))</strong>
                        </div>
                        <div class="stat-item">
                            <span>Range</span>
                            <strong>@((int)(_selectedTowerForUpgrade.Range * (1 + (_selectedTowerForUpgrade.Level - 1) * 0.15f)))</strong>
                        </div>
                        <div class="stat-item">
                            <span>Rate</span>
                            <strong>@_selectedTowerForUpgrade.FireRate.ToString("0.0")/s</strong>
                        </div>
                    </div>

                    <button class="btn-upgrade" @onclick="UpgradeTower"
                            disabled="@(_gold < GetUpgradeCost(_selectedTowerForUpgrade))">
                        ⬆️ Upgrade - 💰 @GetUpgradeCost(_selectedTowerForUpgrade)
                    </button>
                    <button class="btn-sell" @onclick="SellTower">
                        💸 Sell - 💰 @GetSellValue(_selectedTowerForUpgrade)
                    </button>
                    <button class="btn-close" @onclick="CloseUpgradePanel">
                        ✕ Close
                    </button>
                </div>
            }
            else
            {
                <div class="empty-state">
                    <p>👆 Click on a tower to upgrade</p>
                </div>
            }
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="side-panel right-panel">
            <div class="panel-header">
                <h3>🛒 Towers</h3>
            </div>
            <div class="tower-shop">
                @foreach (var towerInfo in _towerInfos)
                {
                    <div class="tower-shop-card @(_selectedTower == towerInfo.Type ? "selected" : "") @(_gold < towerInfo.Cost ? "disabled" : "")"
                         @onclick="() => SelectTower(towerInfo.Type)">
                        <div class="tower-shop-icon">@towerInfo.Emoji</div>
                        <div class="tower-shop-info">
                            <strong>@towerInfo.Name</strong>
                            <div class="tower-shop-stats">
                                <span>💰 @towerInfo.Cost</span>
                                <span>🎯 @towerInfo.Range</span>
                                <span>⚔️ @towerInfo.Damage</span>
                            </div>
                            <small>@towerInfo.Description</small>
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>

    @if (_bossWarning > 0)
    {
        <div class="boss-warning">
            <div class="boss-warning-content">
                <h1>⚠️ BOSS INCOMING ⚠️</h1>
                <div class="boss-countdown">@_bossWarning</div>
            </div>
        </div>
    }

    @if (_isPaused && !_gameOver)
    {
        <div class="pause-overlay">
            <div class="pause-box">
                <h1>⏸️ PAUSED</h1>
                <button class="resume-btn" @onclick="TogglePause">
                    ▶️ Resume
                </button>
            </div>
        </div>
    }

    @if (_gameOver)
    {
        <div class="game-over-overlay">
            <div class="game-over-box">
                <h1>💀 Game Over</h1>
                <div class="final-stats">
                    <p>Wave: <strong>@_currentWave</strong></p>
                    <p>Gold: <strong>@_totalGoldEarned</strong></p>
                    <p>Kills: <strong>@_totalEnemiesKilled</strong></p>
                </div>
                <button class="btn-restart" @onclick="RestartGame">🔄 Restart</button>
            </div>
        </div>
    }
</div>

@code {
    private DotNetObjectReference<TowerDef>? _dotNetRef;
    private bool _isRendered = false;
    private bool _isPaused = false;
    private bool _showTowerRanges = false;
    private bool _autoWave = false;

    private int _gold = 250;
    private int _lives = 20;
    private int _currentWave = 0;
    private int _nextWaveNumber = 1;
    private int _activeWaves = 0;
    private bool _gameOver = false;
    private float _gameSpeed = 1.0f;
    private int _bossWarning = 0;

    private int _totalGoldEarned = 0;
    private int _totalEnemiesKilled = 0;

    private TowerType? _selectedTower = null;
    private Tower? _selectedTowerForUpgrade = null;
    private List<Tower> _towers = new();
    private List<Enemy> _enemies = new();
    private List<Projectile> _projectiles = new();
    private List<Effect> _effects = new();
    private List<List<Point>> _paths = new();

    private System.Threading.Timer? _gameTimer;
    private System.Threading.Timer? _bossWarningTimer;
    private readonly object _lockObject = new();

    private List<TowerInfo> _towerInfos = new()
    {
        new() { Type = TowerType.Basic, Name = "Soldat", Emoji = "🗼", Cost = 50, Range = 100, Damage = 10, Description = "Solider Allrounder" },
        new() { Type = TowerType.Sniper, Name = "Sniper", Emoji = "🎯", Cost = 100, Range = 200, Damage = 50, Description = "Lange Reichweite" },
        new() { Type = TowerType.Cannon, Name = "Kanone", Emoji = "💥", Cost = 150, Range = 80, Damage = 100, Description = "Hoher Schaden" },
        new() { Type = TowerType.Freeze, Name = "Frost", Emoji = "❄️", Cost = 120, Range = 120, Damage = 5, Description = "AOE Freeze Spell" },
        new() { Type = TowerType.Poison, Name = "Gift", Emoji = "☠️", Cost = 110, Range = 100, Damage = 3, Description = "DoT Schaden" },
        new() { Type = TowerType.Lightning, Name = "Blitz", Emoji = "⚡", Cost = 180, Range = 120, Damage = 40, Description = "Chain Lightning" }
    };

    enum TowerType { Basic, Sniper, Cannon, Freeze, Poison, Lightning }
    enum EnemyType { Normal, Fast, Tank, Summoner, BossBrute, BossMage, BossSummoner }
    enum EffectType { Slow, Poison, Stun }

    class Point
    {
        public float X { get; set; }
        public float Y { get; set; }
    }

    class TowerInfo
    {
        public TowerType Type { get; set; }
        public string Name { get; set; } = "";
        public string Emoji { get; set; } = "";
        public int Cost { get; set; }
        public int Range { get; set; }
        public int Damage { get; set; }
        public string Description { get; set; } = "";
    }

    class Enemy
    {
        public float X { get; set; }
        public float Y { get; set; }
        public int PathIndex { get; set; }
        public int PathId { get; set; }
        public float BaseSpeed { get; set; } = 50;
        public float Speed => BaseSpeed * SpeedMultiplier;
        public float SpeedMultiplier { get; set; } = 1.0f;
        public int HP { get; set; } = 100;
        public int MaxHP { get; set; } = 100;
        public float Size { get; set; } = 15;
        public EnemyType Type { get; set; }
        public bool IsDead => HP <= 0;
        public bool IsBoss => Type is EnemyType.BossBrute or EnemyType.BossMage or EnemyType.BossSummoner;

        public float SummonCooldown { get; set; }
        public int SummonCount { get; set; }
        public List<EnemyEffect> ActiveEffects { get; set; } = new();
    }

    class EnemyEffect
    {
        public EffectType Type { get; set; }
        public float Duration { get; set; }
        public float Intensity { get; set; }
        public int DamagePerTick { get; set; }
        public float TickTimer { get; set; }
    }

    class Tower
    {
        public float X { get; set; }
        public float Y { get; set; }
        public TowerType Type { get; set; }
        public float Range { get; set; }
        public float FireRate { get; set; }
        public int Damage { get; set; }
        public float Cooldown { get; set; }
        public int Cost { get; set; }
        public int Level { get; set; } = 1;
        public float SpellCooldown { get; set; }
    }

    class Projectile
    {
        public float X { get; set; }
        public float Y { get; set; }
        public Enemy? Target { get; set; }
        public float Speed { get; set; } = 300;
        public int Damage { get; set; }
        public TowerType TowerType { get; set; }
        public bool Hit { get; set; }
        public int ChainCount { get; set; }
        public List<Enemy> ChainedEnemies { get; set; } = new();
    }

    class Effect
    {
        public float X { get; set; }
        public float Y { get; set; }
        public string Type { get; set; } = "";
        public float Duration { get; set; }
        public float Size { get; set; }
        public Enemy? Target { get; set; }
    }

    private void TogglePause()
    {
        _isPaused = !_isPaused;
        StateHasChanged();
    }

    private void ToggleSpeed()
    {
        if (_isPaused) return;
        _gameSpeed = _gameSpeed switch
        {
            1.0f => 2.0f,
            2.0f => 3.0f,
            3.0f => 4.0f,
            _ => 1.0f
        };
        StateHasChanged();
    }

    private void ToggleTowerRanges()
    {
        _showTowerRanges = !_showTowerRanges;
        StateHasChanged();
    }

    private void ToggleAutoWave()
    {
        _autoWave = !_autoWave;
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        InitializePaths();
        _dotNetRef = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _isRendered = true;

            try
            {
                await JS.InvokeVoidAsync("towerDefense.init");
                await JS.InvokeVoidAsync("towerDefense.setDotNetRef", _dotNetRef);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JS Init Error: {ex.Message}");
            }

            _gameTimer = new System.Threading.Timer(_ =>
            {
                _ = InvokeAsync(() => GameLoop());
            }, null, 100, 16);
        }
    }

    [JSInvokable]
    public async Task OnCanvasClick(float x, float y)
    {
        if (_gameOver || _isPaused) return;

        var clickedTower = _towers.FirstOrDefault(t =>
            Distance(t.X, t.Y, x, y) < 40);

        if (clickedTower != null)
        {
            _selectedTowerForUpgrade = clickedTower;
            _selectedTower = null;
            await InvokeAsync(StateHasChanged);
            return;
        }

        _selectedTowerForUpgrade = null;

        if (_selectedTower == null) return;

        var towerInfo = _towerInfos.First(t => t.Type == _selectedTower.Value);
        var tower = CreateTower(_selectedTower.Value, x, y, towerInfo.Cost);

        if (_gold >= tower.Cost && !IsOnPath(x, y))
        {
            lock (_lockObject)
            {
                _gold -= tower.Cost;
                _towers.Add(tower);
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private void InitializePaths()
    {
        var commonPath = new List<Point>
        {
            new() { X = 800, Y = 450 },
            new() { X = 1000, Y = 450 },
            new() { X = 1000, Y = 300 },
            new() { X = 1200, Y = 300 },
            new() { X = 1200, Y = 450 },
            new() { X = 1500, Y = 450 }
        };

        _paths = new List<List<Point>>
        {
            new List<Point>
            {
                new() { X = 0, Y = 200 },
                new() { X = 300, Y = 200 },
                new() { X = 300, Y = 450 },
                new() { X = 800, Y = 450 }
            }.Concat(commonPath).ToList(),

            new List<Point>
            {
                new() { X = 0, Y = 700 },
                new() { X = 400, Y = 700 },
                new() { X = 400, Y = 450 },
                new() { X = 800, Y = 450 }
            }.Concat(commonPath).ToList(),

            new List<Point>
            {
                new() { X = 600, Y = 0 },
                new() { X = 600, Y = 200 },
                new() { X = 800, Y = 200 },
                new() { X = 800, Y = 450 }
            }.Concat(commonPath).ToList(),

            new List<Point>
            {
                new() { X = 1450, Y = 0 },
                new() { X = 1450, Y = 200 },
                new() { X = 1300, Y = 200 },
                new() { X = 1300, Y = 450 },
                new() { X = 800, Y = 450 }
            }.Concat(commonPath).ToList()
        };
    }

    private List<int> GetActivePathsForWave(int wave)
    {
        if (wave < 15) return new List<int> { 0 };
        if (wave < 25) return new List<int> { 0, 1 };
        if (wave < 30) return new List<int> { 0, 1, 2 };
        return new List<int> { 0, 1, 2, 3 };
    }

    private string GetTowerName(TowerType type)
    {
        return _towerInfos.First(t => t.Type == type).Name;
    }

    private string GetTowerEmoji(TowerType type)
    {
        return _towerInfos.First(t => t.Type == type).Emoji;
    }

    private void SelectTower(TowerType type)
    {
        if (_gold < _towerInfos.First(t => t.Type == type).Cost) return;
        _selectedTower = type;
        _selectedTowerForUpgrade = null;
        StateHasChanged();
    }

    private Tower CreateTower(TowerType type, float x, float y, int cost)
    {
        return type switch
        {
            TowerType.Basic => new Tower { X = x, Y = y, Type = type, Range = 100, FireRate = 1f, Damage = 10, Cost = cost },
            TowerType.Sniper => new Tower { X = x, Y = y, Type = type, Range = 200, FireRate = 2f, Damage = 50, Cost = cost },
            TowerType.Cannon => new Tower { X = x, Y = y, Type = type, Range = 80, FireRate = 0.5f, Damage = 100, Cost = cost },
            TowerType.Freeze => new Tower { X = x, Y = y, Type = type, Range = 120, FireRate = 1.5f, Damage = 5, Cost = cost, SpellCooldown = 5f },
            TowerType.Poison => new Tower { X = x, Y = y, Type = type, Range = 100, FireRate = 1f, Damage = 3, Cost = cost },
            TowerType.Lightning => new Tower { X = x, Y = y, Type = type, Range = 120, FireRate = 1.2f, Damage = 40, Cost = cost },
            _ => throw new ArgumentException()
        };
    }

    private bool IsOnPath(float x, float y)
    {
        const float pathWidth = 50;
        foreach (var path in _paths)
        {
            for (int i = 0; i < path.Count - 1; i++)
            {
                var p1 = path[i];
                var p2 = path[i + 1];
                var dist = DistanceToSegment(x, y, p1.X, p1.Y, p2.X, p2.Y);
                if (dist < pathWidth) return true;
            }
        }
        return false;
    }

    private float DistanceToSegment(float px, float py, float x1, float y1, float x2, float y2)
    {
        var dx = x2 - x1;
        var dy = y2 - y1;
        var len = MathF.Sqrt(dx * dx + dy * dy);
        if (len == 0) return Distance(px, py, x1, y1);

        var t = Math.Max(0, Math.Min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)));
        var projX = x1 + t * dx;
        var projY = y1 + t * dy;

        return Distance(px, py, projX, projY);
    }

    private void StartNextWave()
    {
        if (_gameOver || _isPaused) return;

        var waveNumber = _nextWaveNumber;
        _nextWaveNumber++;

        if (waveNumber > _currentWave)
        {
            _currentWave = waveNumber;
        }

        _activeWaves++;
        StateHasChanged();

        if (waveNumber % 10 == 0)
        {
            _bossWarning = 5;
            _bossWarningTimer?.Dispose();
            _bossWarningTimer = new System.Threading.Timer(_ =>
            {
                _bossWarning--;
                if (_bossWarning <= 0)
                {
                    _bossWarningTimer?.Dispose();
                }
                _ = InvokeAsync(StateHasChanged);
            }, null, 1000, 1000);
        }

        _ = Task.Run(async () => await SpawnWave(waveNumber));
    }

    private async Task SpawnWave(int wave)
    {
        try
        {
            var config = GetWaveConfig(wave);
            var activePaths = GetActivePathsForWave(wave);

            if (wave % 10 == 0)
            {
                await Task.Delay(5000);
            }

            for (int i = 0; i < config.EnemyCount; i++)
            {
                if (_gameOver) break;

                var enemyType = SelectEnemyType(wave, i, config);
                var pathId = activePaths[Random.Shared.Next(activePaths.Count)];
                var enemy = CreateEnemy(enemyType, wave, pathId);

                lock (_lockObject)
                {
                    _enemies.Add(enemy);
                }

                await Task.Delay(config.SpawnDelay);
            }
        }
        finally
        {
            _activeWaves--;
            await InvokeAsync(StateHasChanged);
        }
    }

    private (int EnemyCount, int SpawnDelay, float Difficulty) GetWaveConfig(int wave)
    {
        var baseCount = 5 + wave * 3;
        var spawnDelay = Math.Max(200, 1000 - wave * 15);
        var difficulty = 1 + (wave * 0.15f);

        return (baseCount, spawnDelay, difficulty);
    }

    private EnemyType SelectEnemyType(int wave, int index, (int EnemyCount, int SpawnDelay, float Difficulty) config)
    {
        if (wave % 10 == 0 && index == config.EnemyCount - 1)
        {
            return wave % 30 == 0 ? EnemyType.BossSummoner :
                   wave % 20 == 0 ? EnemyType.BossMage :
                   EnemyType.BossBrute;
        }

        if (wave > 5 && Random.Shared.Next(100) < wave * 2)
        {
            return EnemyType.Summoner;
        }

        var roll = Random.Shared.Next(100);
        if (roll < 30) return EnemyType.Fast;
        if (roll < 60) return EnemyType.Normal;
        return EnemyType.Tank;
    }

    private Enemy CreateEnemy(EnemyType type, int wave, int pathId)
    {
        var baseDifficulty = 1 + (wave * 0.15f);
        var startPos = _paths[pathId][0];

        return type switch
        {
            EnemyType.Normal => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 50,
                HP = (int)(100 * baseDifficulty),
                MaxHP = (int)(100 * baseDifficulty),
                Size = 15
            },
            EnemyType.Fast => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 80,
                HP = (int)(60 * baseDifficulty),
                MaxHP = (int)(60 * baseDifficulty),
                Size = 12
            },
            EnemyType.Tank => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 30,
                HP = (int)(300 * baseDifficulty),
                MaxHP = (int)(300 * baseDifficulty),
                Size = 20
            },
            EnemyType.Summoner => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 40,
                HP = (int)(150 * baseDifficulty),
                MaxHP = (int)(150 * baseDifficulty),
                Size = 16,
                SummonCooldown = 5f,
                SummonCount = 3
            },
            EnemyType.BossBrute => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 25,
                HP = (int)(1500 * baseDifficulty),
                MaxHP = (int)(1500 * baseDifficulty),
                Size = 35
            },
            EnemyType.BossMage => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 35,
                HP = (int)(1200 * baseDifficulty),
                MaxHP = (int)(1200 * baseDifficulty),
                Size = 32
            },
            EnemyType.BossSummoner => new Enemy
            {
                X = startPos.X,
                Y = startPos.Y,
                PathId = pathId,
                Type = type,
                BaseSpeed = 30,
                HP = (int)(1300 * baseDifficulty),
                MaxHP = (int)(1300 * baseDifficulty),
                Size = 33,
                SummonCooldown = 3f,
                SummonCount = 5
            },
            _ => throw new ArgumentException()
        };
    }

    private async void GameLoop()
    {
        if (_gameOver || !_isRendered || _isPaused) return;

        var dt = 0.016f * _gameSpeed;

        lock (_lockObject)
        {
            UpdateEnemies(dt);
            UpdateTowers(dt);
            UpdateProjectiles(dt);
            UpdateEffects(dt);
        }

        // Auto-Wave: Nur wenn aktiviert UND keine Welle läuft UND keine Gegner mehr da
        if (_autoWave && _activeWaves == 0 && _enemies.Count == 0)
        {
            await Task.Delay(2000);
            if (_autoWave && !_gameOver && !_isPaused && _activeWaves == 0 && _enemies.Count == 0)
            {
                StartNextWave();
            }
        }

        await InvokeAsync(StateHasChanged);
        await RenderGame();
    }

    private void UpdateEnemies(float dt)
    {
        var enemiesToRemove = new List<Enemy>();

        foreach (var enemy in _enemies.ToList())
        {
            if (enemy.IsDead) continue;

            UpdateEnemyEffects(enemy, dt);

            if (enemy.Type is EnemyType.Summoner or EnemyType.BossSummoner)
            {
                enemy.SummonCooldown -= dt;
                if (enemy.SummonCooldown <= 0 && enemy.SummonCount > 0)
                {
                    SpawnSummonedEnemy(enemy);
                    enemy.SummonCooldown = enemy.Type == EnemyType.BossSummoner ? 3f : 5f;
                    enemy.SummonCount--;
                }
            }

            var path = _paths[enemy.PathId];
            if (enemy.PathIndex >= path.Count - 1)
            {
                enemiesToRemove.Add(enemy);
                _lives--;

                if (_lives <= 0)
                {
                    _gameOver = true;
                }
                continue;
            }

            var target = path[enemy.PathIndex + 1];
            var dx = target.X - enemy.X;
            var dy = target.Y - enemy.Y;
            var dist = MathF.Sqrt(dx * dx + dy * dy);

            if (dist < 5)
            {
                enemy.PathIndex++;
            }
            else
            {
                enemy.X += (dx / dist) * enemy.Speed * dt;
                enemy.Y += (dy / dist) * enemy.Speed * dt;
            }
        }

        foreach (var e in enemiesToRemove)
        {
            _enemies.Remove(e);
        }

        _enemies.RemoveAll(e => e.IsDead);
    }

    private void UpdateEnemyEffects(Enemy enemy, float dt)
    {
        enemy.SpeedMultiplier = 1.0f;

        for (int i = enemy.ActiveEffects.Count - 1; i >= 0; i--)
        {
            var effect = enemy.ActiveEffects[i];
            effect.Duration -= dt;

            if (effect.Duration <= 0)
            {
                enemy.ActiveEffects.RemoveAt(i);
                continue;
            }

            switch (effect.Type)
            {
                case EffectType.Slow:
                    enemy.SpeedMultiplier = Math.Min(enemy.SpeedMultiplier, 1.0f - effect.Intensity);
                    break;

                case EffectType.Poison:
                    effect.TickTimer -= dt;
                    if (effect.TickTimer <= 0)
                    {
                        enemy.HP -= effect.DamagePerTick;
                        effect.TickTimer = 0.5f;

                        if (enemy.IsDead)
                        {
                            _gold += GetEnemyGoldReward(enemy);
                            _totalGoldEarned += GetEnemyGoldReward(enemy);
                            _totalEnemiesKilled++;
                        }
                    }
                    break;
            }
        }
    }

    private void SpawnSummonedEnemy(Enemy summoner)
    {
        var minion = new Enemy
        {
            X = summoner.X + Random.Shared.Next(-20, 20),
            Y = summoner.Y + Random.Shared.Next(-20, 20),
            PathIndex = summoner.PathIndex,
            PathId = summoner.PathId,
            Type = EnemyType.Normal,
            BaseSpeed = 60,
            HP = 30,
            MaxHP = 30,
            Size = 10
        };

        _enemies.Add(minion);

        _effects.Add(new Effect
        {
            X = summoner.X,
            Y = summoner.Y,
            Type = "summon",
            Duration = 0.5f,
            Size = 40
        });
    }

    private void UpdateTowers(float dt)
    {
        foreach (var tower in _towers)
        {
            tower.Cooldown -= dt;

            if (tower.Type == TowerType.Freeze)
            {
                tower.SpellCooldown -= dt;
                if (tower.SpellCooldown <= 0)
                {
                    CastFreezeSpell(tower);
                    tower.SpellCooldown = 5f / (1 + (tower.Level - 1) * 0.2f);
                }
            }

            if (tower.Cooldown > 0) continue;

            var target = FindTarget(tower);

            if (target != null)
            {
                tower.Cooldown = tower.FireRate / (1 + (tower.Level - 1) * 0.2f);

                var projectile = new Projectile
                {
                    X = tower.X,
                    Y = tower.Y,
                    Target = target,
                    Damage = (int)(tower.Damage * (1 + (tower.Level - 1) * 0.5f)),
                    TowerType = tower.Type,
                    ChainCount = tower.Type == TowerType.Lightning ? 3 + tower.Level : 0
                };

                if (tower.Type == TowerType.Lightning)
                {
                    projectile.ChainedEnemies.Add(target);
                }

                _projectiles.Add(projectile);
            }
        }
    }

    private void CastFreezeSpell(Tower tower)
    {
        var spellRange = tower.Range * 1.5f * (1 + (tower.Level - 1) * 0.2f);
        var affected = 0;

        foreach (var enemy in _enemies.Where(e => !e.IsDead))
        {
            if (Distance(enemy.X, enemy.Y, tower.X, tower.Y) < spellRange)
            {
                ApplyEffect(enemy, EffectType.Slow, 3f, 0.7f);
                affected++;
            }
        }

        if (affected > 0)
        {
            _effects.Add(new Effect
            {
                X = tower.X,
                Y = tower.Y,
                Type = "freeze_spell",
                Duration = 1f,
                Size = spellRange
            });
        }
    }

    private Enemy? FindTarget(Tower tower)
    {
        return _enemies
            .Where(e => !e.IsDead && Distance(e.X, e.Y, tower.X, tower.Y) < tower.Range * (1 + (tower.Level - 1) * 0.15f))
            .OrderByDescending(e => e.PathIndex)
            .ThenBy(e => e.HP)
            .FirstOrDefault();
    }

    private void UpdateProjectiles(float dt)
    {
        var projectilesToRemove = new List<Projectile>();

        foreach (var proj in _projectiles.ToList())
        {
            if (proj.Hit || proj.Target == null || proj.Target.IsDead)
            {
                projectilesToRemove.Add(proj);
                continue;
            }

            var dx = proj.Target.X - proj.X;
            var dy = proj.Target.Y - proj.Y;
            var dist = MathF.Sqrt(dx * dx + dy * dy);

            if (dist < 10)
            {
                HitEnemy(proj.Target, proj);
                proj.Hit = true;
                projectilesToRemove.Add(proj);

                if (proj.TowerType == TowerType.Lightning && proj.ChainCount > 0)
                {
                    var nextTarget = _enemies
                        .Where(e => !e.IsDead &&
                                   !proj.ChainedEnemies.Contains(e) &&
                                   Distance(e.X, e.Y, proj.Target.X, proj.Target.Y) < 150)
                        .OrderBy(e => Distance(e.X, e.Y, proj.Target.X, proj.Target.Y))
                        .FirstOrDefault();

                    if (nextTarget != null)
                    {
                        _effects.Add(new Effect
                        {
                            X = proj.Target.X,
                            Y = proj.Target.Y,
                            Type = "lightning_chain",
                            Duration = 0.3f,
                            Size = 10,
                            Target = nextTarget
                        });

                        var chainedEnemies = new List<Enemy>(proj.ChainedEnemies) { nextTarget };

                        _projectiles.Add(new Projectile
                        {
                            X = proj.Target.X,
                            Y = proj.Target.Y,
                            Target = nextTarget,
                            Damage = (int)(proj.Damage * 0.8f),
                            TowerType = proj.TowerType,
                            ChainCount = proj.ChainCount - 1,
                            Speed = proj.Speed * 1.5f,
                            ChainedEnemies = chainedEnemies
                        });
                    }
                }
            }
            else
            {
                proj.X += (dx / dist) * proj.Speed * dt;
                proj.Y += (dy / dist) * proj.Speed * dt;
            }
        }

        foreach (var p in projectilesToRemove)
        {
            _projectiles.Remove(p);
        }
    }

    private void HitEnemy(Enemy enemy, Projectile proj)
    {
        enemy.HP -= proj.Damage;

        _effects.Add(new Effect
        {
            X = enemy.X,
            Y = enemy.Y,
            Type = "hit",
            Duration = 0.3f,
            Size = 20
        });

        switch (proj.TowerType)
        {
            case TowerType.Freeze:
                ApplyEffect(enemy, EffectType.Slow, 2f, 0.5f);
                break;

            case TowerType.Poison:
                ApplyEffect(enemy, EffectType.Poison, 3f, 0, proj.Damage * 2);
                break;
        }

        if (enemy.IsDead)
        {
            var goldReward = GetEnemyGoldReward(enemy);
            _gold += goldReward;
            _totalGoldEarned += goldReward;
            _totalEnemiesKilled++;

            _effects.Add(new Effect
            {
                X = enemy.X,
                Y = enemy.Y,
                Type = "death",
                Duration = 0.5f,
                Size = enemy.Size
            });
        }
    }

    private void ApplyEffect(Enemy enemy, EffectType type, float duration, float intensity, int damagePerTick = 0)
    {
        var existingEffect = enemy.ActiveEffects.FirstOrDefault(e => e.Type == type);

        if (existingEffect != null)
        {
            existingEffect.Duration = Math.Max(existingEffect.Duration, duration);
        }
        else
        {
            enemy.ActiveEffects.Add(new EnemyEffect
            {
                Type = type,
                Duration = duration,
                Intensity = intensity,
                DamagePerTick = damagePerTick,
                TickTimer = 0.5f
            });
        }
    }

    private int GetEnemyGoldReward(Enemy enemy)
    {
        return enemy.Type switch
        {
            EnemyType.Normal => 10 + _currentWave * 2,
            EnemyType.Fast => 8 + _currentWave * 2,
            EnemyType.Tank => 20 + _currentWave * 3,
            EnemyType.Summoner => 25 + _currentWave * 3,
            EnemyType.BossBrute => 150 + _currentWave * 15,
            EnemyType.BossMage => 180 + _currentWave * 15,
            EnemyType.BossSummoner => 200 + _currentWave * 15,
            _ => 10
        };
    }

    private void UpdateEffects(float dt)
    {
        for (int i = _effects.Count - 1; i >= 0; i--)
        {
            _effects[i].Duration -= dt;
            if (_effects[i].Duration <= 0)
            {
                _effects.RemoveAt(i);
            }
        }
    }

    private void UpgradeTower()
    {
        if (_selectedTowerForUpgrade == null) return;
        var cost = GetUpgradeCost(_selectedTowerForUpgrade);
        if (_gold >= cost)
        {
            _gold -= cost;
            _selectedTowerForUpgrade.Level++;
            StateHasChanged();
        }
    }

    private void SellTower()
    {
        if (_selectedTowerForUpgrade == null) return;
        var value = GetSellValue(_selectedTowerForUpgrade);
        _gold += value;
        _towers.Remove(_selectedTowerForUpgrade);
        _selectedTowerForUpgrade = null;
        StateHasChanged();
    }

    private void CloseUpgradePanel()
    {
        _selectedTowerForUpgrade = null;
        StateHasChanged();
    }

    private int GetUpgradeCost(Tower tower)
    {
        return (int)(tower.Cost * 0.7f * tower.Level);
    }

    private int GetSellValue(Tower tower)
    {
        var totalCost = tower.Cost;
        for (int i = 1; i < tower.Level; i++)
        {
            totalCost += (int)(tower.Cost * 0.7f * i);
        }
        return (int)(totalCost * 0.6f);
    }

    private float Distance(float x1, float y1, float x2, float y2)
    {
        var dx = x2 - x1;
        var dy = y2 - y1;
        return MathF.Sqrt(dx * dx + dy * dy);
    }

    private async Task RenderGame()
    {
        if (!_isRendered) return;

        try
        {
            List<List<Point>> pathsCopy;
            List<Enemy> enemiesCopy;
            List<Tower> towersCopy;
            List<Projectile> projectilesCopy;
            List<Effect> effectsCopy;

            lock (_lockObject)
            {
                pathsCopy = _paths.Select(p => p.ToList()).ToList();
                enemiesCopy = _enemies.Select(e => new Enemy
                {
                    X = e.X,
                    Y = e.Y,
                    HP = e.HP,
                    MaxHP = e.MaxHP,
                    Size = e.Size,
                    Type = e.Type,
                    ActiveEffects = e.ActiveEffects.ToList()
                }).ToList();
                towersCopy = _towers.Select(t => new Tower
                {
                    X = t.X,
                    Y = t.Y,
                    Type = t.Type,
                    Range = t.Range,
                    Level = t.Level
                }).ToList();
                projectilesCopy = _projectiles.Select(p => new Projectile
                {
                    X = p.X,
                    Y = p.Y,
                    TowerType = p.TowerType
                }).ToList();
                effectsCopy = _effects.Select(e => new Effect
                {
                    X = e.X,
                    Y = e.Y,
                    Type = e.Type,
                    Duration = e.Duration,
                    Size = e.Size,
                    Target = e.Target != null ? new Enemy
                    {
                        X = e.Target.X,
                        Y = e.Target.Y
                    } : null
                }).ToList();
            }

            var activePaths = GetActivePathsForWave(_currentWave);

            var data = new
            {
                paths = pathsCopy,
                activePaths = activePaths,
                currentWave = _currentWave,
                enemies = enemiesCopy.Select(e => new
                {
                    x = e.X,
                    y = e.Y,
                    hp = e.HP,
                    maxHP = e.MaxHP,
                    size = e.Size,
                    type = (int)e.Type,
                    isBoss = e.IsBoss,
                    hasPoison = e.ActiveEffects.Any(ef => ef.Type == EffectType.Poison),
                    hasSlow = e.ActiveEffects.Any(ef => ef.Type == EffectType.Slow)
                }),
                towers = towersCopy.Select(t => new
                {
                    x = t.X,
                    y = t.Y,
                    type = (int)t.Type,
                    range = t.Range * (1 + (t.Level - 1) * 0.15f),
                    level = t.Level
                }),
                projectiles = projectilesCopy.Select(p => new
                {
                    x = p.X,
                    y = p.Y,
                    type = (int)p.TowerType
                }),
                effects = effectsCopy.Select(e => new
                {
                    x = e.X,
                    y = e.Y,
                    type = e.Type,
                    duration = e.Duration,
                    size = e.Size,
                    target = e.Target != null ? new { x = e.Target.X, y = e.Target.Y } : null
                }),
                selectedTower = _selectedTower,
                showTowerRanges = _showTowerRanges
            };

            await JS.InvokeVoidAsync("towerDefense.render", data);
        }
        catch (Exception)
        {
        }
    }

    private void RestartGame()
    {
        lock (_lockObject)
        {
            _gold = 250;
            _lives = 20;
            _currentWave = 0;
            _nextWaveNumber = 1;
            _activeWaves = 0;
            _gameOver = false;
            _gameSpeed = 1.0f;
            _isPaused = false;
            _bossWarning = 0;
            _totalGoldEarned = 0;
            _totalEnemiesKilled = 0;
            _showTowerRanges = false;
            _autoWave = false;
            _towers.Clear();
            _enemies.Clear();
            _projectiles.Clear();
            _effects.Clear();
            _selectedTower = null;
            _selectedTowerForUpgrade = null;
        }
        _bossWarningTimer?.Dispose();
        StateHasChanged();
    }

    public void Dispose()
    {
        _gameTimer?.Dispose();
        _bossWarningTimer?.Dispose();
        _dotNetRef?.Dispose();
    }
}