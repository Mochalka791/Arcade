@page "/tetris"
@rendermode InteractiveServer
@layout Arcade.Components.Layout.MainLayout
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using System
@using System.Collections.Generic
@using System.Linq
@using System.Threading
@using System.Threading.Tasks
@using Microsoft.AspNetCore.Components.Web
@using Arcade.Games.Tetris
@using Arcade.Data
@using Arcade.Data.Entities
@using Arcade.Data.Services
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using Microsoft.EntityFrameworkCore

@inject ITetrisStatsService TetrisStatsService
@inject ArcadeDbContext Db
@inject AuthenticationStateProvider AuthStateProvider
@implements IAsyncDisposable

<PageTitle>Tetris</PageTitle>

<section class="tetris">

    <header class="tetris__header">
        <h1>Tetris</h1>
        <div class="tetris__actions">
            <button class="arcade-btn" style="scale: 0.9;" @onclick="ToggleAuto">
                @_engine.AutoPlay ? "Auto"
            </button>

            <button class="arcade-btn" @onclick="TogglePause">
                @(_engine.IsPaused ? "Weiter" : "Pause")
            </button>

            <button class="arcade-btn" @onclick="ResetGameAsync">Neu starten</button>

        </div>

    </header>

    <div class="tetris__layout">

        <div class="tetris__board"
             tabindex="0"
             role="application"
             aria-label="Tetris-Spielfeld"
             @ref="_boardRef"
             @onkeydown="HandleKeyDown"
             @onkeydown:preventDefault="true"
             @onkeydown:stopPropagation="true">

            @{
                var currentCells = _engine.GetCurrentCells();
                var ghostCells = _engine.GetGhostCells();
                var type = _engine.CurrentPiece;
            }

            @for (var r = 0; r < TetrisEngine.BoardHeight; r++)
            {
                @for (var c = 0; c < TetrisEngine.BoardWidth; c++)
                {
                    var css = BuildCellClasses(r, c, currentCells, ghostCells, type);
                    <div class="@css"></div>
                }
            }
        </div>

        <aside class="tetris__sidebar-left">
            <div class="tetris__panel">
                <h2>Score</h2>
                <p>@_engine.Score</p>
            </div>
            <div class="tetris__panel">
                <h2>Level</h2>
                <p>@_engine.Level</p>
            </div>
            <div class="tetris__panel">
                <h2>Lines</h2>
                <p>@_engine.LinesCleared</p>
            </div>
        </aside>

        <aside class="tetris__sidebar-right">
            <div class="tetris__panel">
                <h2>Top 10</h2>
                <table class="tetris-top">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Spieler</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
                        @if (_topRecords.Count == 0)
                        {
                            <tr>
                                <td colspan="3" class="empty">Noch keine Eintr√§ge</td>
                            </tr>
                        }
                        else
                        {
                            @for (var i = 0; i < _topRecords.Count; i++)
                            {
                                var rec = _topRecords[i];
                                <tr>
                                    <td>@(i + 1)</td>
                                    <td>@rec.UserName</td>
                                    <td>@rec.HighScore</td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
        </aside>

    </div>

    @if (_engine.IsGameOver)
    {
        <div class="tetris__overlay">
            <div class="overlay-card">
                <h2>Game Over</h2>
                <p>Score: @_engine.Score</p>
                <p>Level: @_engine.Level</p>
                <button class="arcade-btn" @onclick="ResetGameAsync">Nochmal</button>
            </div>
        </div>
    }
</section>

@code {
    private readonly TetrisEngine _engine = new();

    private CancellationTokenSource? _ctsLoop;
    private bool _loopStarted = false;
    private bool _statsSavedThisGame = false;

    private int _lastSavedScore = 0;
    private int _lastSavedLevel = 1;

    private ElementReference _boardRef;

    private List<TetrisRecord> _topRecords = new();

    private sealed record TetrisRecord(string UserName, int HighScore);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_loopStarted)
        {
            await StartLoopAsync();
            _loopStarted = true;
        }

        if (firstRender)
        {
            await LoadTopAsync();
            await FocusBoardAsync();
        }
    }

    private async Task StartLoopAsync()
    {
        StopLoop();
        _ctsLoop = new CancellationTokenSource();
        _ = RunLoopAsync(_ctsLoop.Token);
        await Task.CompletedTask;
    }

    private async Task RunLoopAsync(CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                await Task.Delay(_engine.TickInterval, token);

                if (_engine.IsPaused)
                    continue;

                if (_engine.IsGameOver)
                {
                    if (!_statsSavedThisGame)
                    {
                        _statsSavedThisGame = true;

                        await SaveStatsAsync(_engine.Score, _engine.Level, isGameOver: true);
                        await LoadTopAsync();
                    }
                    continue;
                }

                _engine.Tick();

                var score = _engine.Score;
                var level = _engine.Level;

                if (score > _lastSavedScore)
                {
                    _lastSavedScore = score;
                    _lastSavedLevel = level;

                    await SaveStatsAsync(score, level, isGameOver: false);
                }

                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException) { }
    }

    private void StopLoop()
    {
        var old = Interlocked.Exchange(ref _ctsLoop, null);
        if (old is null) return;

        try { old.Cancel(); }
        catch { }
        finally { old.Dispose(); }
    }

    private async Task SaveStatsAsync(int score, int level, bool isGameOver)
    {
        var userId = await ResolveUserIdAsync();
        if (userId is null) return;

        await TetrisStatsService.UpdateAfterGameAsync(
            userId.Value,
            score,
            level,
            isGameOver);
    }

    private async Task LoadTopAsync()
    {
        _topRecords = await Db.TetrisStats
            .Include(t => t.User)
            .OrderByDescending(t => t.HighScore)
            .Take(10)
            .Select(t => new TetrisRecord(t.User.Username, t.HighScore))
            .ToListAsync();
    }

    private async Task<int?> ResolveUserIdAsync()
    {
        var auth = await AuthStateProvider.GetAuthenticationStateAsync();
        var p = auth.User;

        if (p.Identity is not { IsAuthenticated: true })
            return null;

        var claim =
            p.FindFirst(ClaimTypes.NameIdentifier) ??
            p.FindFirst("userId") ??
            p.FindFirst("sub");

        if (claim != null && int.TryParse(claim.Value, out var id))
            return id;

        var username = p.Identity?.Name;
        if (string.IsNullOrWhiteSpace(username)) return null;

        var dbUser = await Db.Users.FirstOrDefaultAsync(u => u.Username == username);
        return dbUser?.Id;
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (_engine.IsGameOver)
        {
            if (e.Key is " " or "Enter")
                await ResetGameAsync();
            return;
        }



        if (e.Key is "p" or "P")
        {
            _engine.TogglePause();
            StateHasChanged();
            return;
        }

        if (_engine.IsPaused)
            return;

        switch (e.Key)
        {
            case "ArrowLeft":
            case "Left":
                _engine.MoveLeft();
                break;
            case "ArrowRight":
            case "Right":
                _engine.MoveRight();
                break;
            case "ArrowDown":
            case "Down":
                _engine.SoftDrop();
                break;
            case "ArrowUp":
            case "Up":
                _engine.RotateClockwise();
                break;
            case "z":
            case "Z":
                _engine.RotateCounterClockwise();
                break;
            case " ":
            case "Space":
            case "Spacebar":
                _engine.HardDrop();
                break;
            case "Shift":
            case "ShiftLeft":
            case "ShiftRight":
                _engine.Hold();
                break;
        }

        StateHasChanged();
        await Task.CompletedTask;
    }

    private void ToggleAuto()
    {
        _engine.AutoPlay = !_engine.AutoPlay;
    }

    private async Task ResetGameAsync()
    {
        _engine.Reset();
        _statsSavedThisGame = false;
        _lastSavedScore = 0;
        _lastSavedLevel = 1;

        await FocusBoardAsync();
        StateHasChanged();
    }

    private async Task HardDropAsync()
    {
        if (_engine.IsPaused || _engine.IsGameOver)
            return;

        _engine.HardDrop();
        StateHasChanged();
        await Task.CompletedTask;
    }

    private async Task TogglePause()
    {
        _engine.TogglePause();
        StateHasChanged();
        await Task.CompletedTask;
    }

    private async Task FocusBoardAsync()
    {
        try { await _boardRef.FocusAsync(); }
        catch { }
    }

    public ValueTask DisposeAsync()
    {
        StopLoop();
        return ValueTask.CompletedTask;
    }

    private string BuildCellClasses(
        int row,
        int col,
        IReadOnlyList<BoardPoint> cur,
        IReadOnlyList<BoardPoint> ghost,
        TetrominoType? type)
    {
        var css = new List<string> { "cell" };

        var locked = _engine.GetLockedCell(row, col);
        if (locked is TetrominoType lt)
        {
            css.Add("filled");
            css.Add(Tetrominoes.Get(lt).CssClass);
            return string.Join(" ", css);
        }

        if (type is TetrominoType t)
        {
            if (cur.Any(c => c.Row == row && c.Col == col))
            {
                css.Add("active");
                css.Add(Tetrominoes.Get(t).CssClass);
            }
            else if (ghost.Any(c => c.Row == row && c.Col == col))
            {
                css.Add("ghost");
                css.Add(Tetrominoes.Get(t).CssClass);
            }
        }

        return string.Join(" ", css);
    }
}
