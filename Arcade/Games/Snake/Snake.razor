@page "/snake"
@layout Arcade.Components.Layout.MainLayout
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer

@using System.Threading
@using Arcade.Games.Snake
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.EntityFrameworkCore
@using Arcade.Data
@using Arcade.Data.Entities
@using System.Security.Claims

@attribute [Authorize]

@inject ArcadeDbContext Db
@inject AuthenticationStateProvider AuthStateProvider

@implements IAsyncDisposable

@code {
    private sealed record SnakeRecord(string UserName, int Score);
    private bool _autoMode = false;

    private readonly SnakeEngine _engine = new();
    private readonly object _lockObj = new();
    private CancellationTokenSource? _cts;
    private Task? _loop;
    private int _tickGuard;

    private List<SnakeRecord> _records = new();
    private bool _recordSavedThisGame = false;

    private ElementReference _gridRef;
    private bool _focusedOnce;

    protected override async Task OnInitializedAsync()
    {
        lock (_lockObj) _engine.Reset();
        await LoadTopAsync();      
        await StartLoopAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_focusedOnce)
        {
            _focusedOnce = true;
            try { await _gridRef.FocusAsync(); } catch { }
        }
    }
    private Task ToggleAuto()
    {
        _autoMode = !_autoMode;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void PerformAutoMove()
    {
        var head = _engine.Head;
        var food = _engine.Food;
        var body = new HashSet<(int x, int y)>(_engine.Body);

        var moves = new List<(int dx, int dy, Action move)>
    {
        (0, -1, _engine.TurnUp),
        (0,  1, _engine.TurnDown),
        (-1, 0, _engine.TurnLeft),
        (1,  0, _engine.TurnRight),
    };

        (Action move, int score)? best = null;

        foreach (var (dx, dy, move) in moves)
        {
            var nx = head.x + dx;
            var ny = head.y + dy;

            if (!_engine.WrapWalls)
            {
                if (nx < 0 || nx >= SnakeEngine.Width ||
                    ny < 0 || ny >= SnakeEngine.Height)
                {
                    continue;
                }
            }
            else
            {
                nx = (nx + SnakeEngine.Width) % SnakeEngine.Width;
                ny = (ny + SnakeEngine.Height) % SnakeEngine.Height;
            }

            if (body.Contains((nx, ny)))
                continue;

            var dist = Math.Abs(food.x - nx) + Math.Abs(food.y - ny);
            var score = -dist;

            if (best is null || score > best.Value.score)
            {
                best = (move, score);
            }
        }
        if (best != null)
        {
            best.Value.move();
        }
        else
        {
            _engine.TurnUp();
        }

    }

    private async Task StartLoopAsync()
    {
        await StopLoopAsync();
        _cts = new CancellationTokenSource();
        _loop = RunLoopAsync(_cts.Token);
    }

    private async Task StopLoopAsync()
    {
        if (_cts is null) return;
        _cts.Cancel();
        try
        {
            if (_loop is not null)
                await _loop;
        }
        catch (OperationCanceledException) { }
        finally
        {
            _cts.Dispose();
            _cts = null;
            _loop = null;
        }
    }

    private async Task RunLoopAsync(CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                TimeSpan interval;
                lock (_lockObj) interval = _engine.TickInterval;

                using var timer = new PeriodicTimer(interval);
                while (await timer.WaitForNextTickAsync(token))
                {
                    var shouldRender = false;

                    if (Interlocked.Exchange(ref _tickGuard, 1) == 0)
                    {
                        try
                        {
                            lock (_lockObj)
                            {
                                if (!_engine.IsPaused && !_engine.IsGameOver)
                                {
                                    if (_autoMode)
                                    {
                                        PerformAutoMove();
                                    }

                                    _engine.Tick();
                                    interval = _engine.TickInterval;
                                    shouldRender = true;
                                }
                            }

                        }
                        finally
                        {
                            Interlocked.Exchange(ref _tickGuard, 0);
                        }
                    }
                    if (_engine.IsGameOver && !_recordSavedThisGame)
                    {
                        _recordSavedThisGame = true;

                        int finalScore;
                        lock (_lockObj)
                        {
                            finalScore = _engine.Score;
                        }

                        await SaveStatsAsync(finalScore, token);
                        await LoadTopAsync(token);
                    }

                    if (shouldRender)
                        await InvokeAsync(StateHasChanged);

                    if (interval != timer.Period)
                        break;
                }
            }
        }
        catch (OperationCanceledException) { }
    }

    private async Task<int?> ResolveUserIdAsync(CancellationToken token = default)
    {
        var auth = await AuthStateProvider.GetAuthenticationStateAsync();
        var principal = auth.User;

        if (principal.Identity is not { IsAuthenticated: true })
            return null;

        var idClaim =
            principal.FindFirst(ClaimTypes.NameIdentifier) ??
            principal.FindFirst("userId") ??
            principal.FindFirst("sub") ??
            principal.FindFirst("id");

        if (idClaim != null && int.TryParse(idClaim.Value, out var parsedId))
            return parsedId;

        var username = principal.Identity?.Name;
        if (string.IsNullOrWhiteSpace(username))
            return null;

        var dbUser = await Db.Users
            .FirstOrDefaultAsync(u => u.Username == username, cancellationToken: token);

        return dbUser?.Id;
    }

    private async Task SaveStatsAsync(int score, CancellationToken token)
    {
        if (score <= 0) return;

        var userId = await ResolveUserIdAsync(token);
        if (userId is null) return;

        var stats = await Db.SnakeStats
            .FirstOrDefaultAsync(s => s.UserId == userId.Value, token);

        if (stats == null)
        {
            stats = new SnakeStats
            {
                UserId = userId.Value,
                HighScore = score,
                GamesPlayed = 0,
                AverageScore = 0m
            };
            Db.SnakeStats.Add(stats);
        }

        stats.GamesPlayed++;

        if (score > stats.HighScore)
        {
            stats.HighScore = score;
        }

        stats.AverageScore =
            ((stats.AverageScore * (stats.GamesPlayed - 1)) + score)
            / stats.GamesPlayed;

        await Db.SaveChangesAsync(token);
    }

    private async Task LoadTopAsync(CancellationToken token = default)
    {
        try
        {
            _records = await Db.SnakeStats
                .Include(s => s.User)
                .OrderByDescending(s => s.HighScore)
                .Take(10)
                .Select(s => new SnakeRecord(s.User.Username, s.HighScore))
                .ToListAsync(token);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Fehler beim Laden der Snake-Top-List: {ex.Message}");
            _records = new List<SnakeRecord>();
        }
    }

    private sealed record SnakeSnapshot(
        HashSet<(int x, int y)> Body,
        (int x, int y) Head,
        (int x, int y) Food,
        int Score,
        int HighScore,
        bool IsPaused,
        bool IsGameOver,
        bool WrapWalls,
        TimeSpan TickInterval,
        bool AteFoodLastTick);

    private SnakeSnapshot Snapshot
    {
        get
        {
            lock (_lockObj)
            {
                return new SnakeSnapshot(
                    new HashSet<(int x, int y)>(_engine.Body),
                    _engine.Head,
                    _engine.Food,
                    _engine.Score,
                    _engine.HighScore,
                    _engine.IsPaused,
                    _engine.IsGameOver,
                    _engine.WrapWalls,
                    _engine.TickInterval,
                    _engine.AteFoodLastTick
                );
            }
        }
    }

    private string GetStatusText(SnakeSnapshot s)
        => s.IsGameOver ? "Game Over" : s.IsPaused ? "Paused" : "Running";

    private string GetPauseButtonLabel(SnakeSnapshot s)
        => s.IsGameOver ? "Restart" : s.IsPaused ? "Resume" : "Pause";

    private string GetWrapButtonLabel(SnakeSnapshot s)
        => s.WrapWalls ? "Disable Wrap" : "Enable Wrap";

    private string GetCellClasses(int x, int y, SnakeSnapshot s)
    {
        var cls = new List<string> { "cell" };
        if (s.Head.x == x && s.Head.y == y)
        {
            cls.Add("head");
            if (s.AteFoodLastTick) cls.Add("ate");
        }
        else if (s.Body.Contains((x, y)))
        {
            cls.Add("snake");
        }

        if (s.Food.x == x && s.Food.y == y)
            cls.Add("food");

        return string.Join(' ', cls);
    }

    private Task TogglePause()
    {
        lock (_lockObj)
        {
            if (_engine.IsGameOver)
            {
                var wrap = _engine.WrapWalls;
                _engine.Reset();
                _engine.WrapWalls = wrap;
            }
            else
            {
                _engine.TogglePause();
            }
        }
        _recordSavedThisGame = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task ResetGame()
    {
        lock (_lockObj)
        {
            var w = _engine.WrapWalls;
            _engine.Reset();
            _engine.WrapWalls = w;
            _recordSavedThisGame = false;
        }

        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task ToggleWrap()
    {
        lock (_lockObj) _engine.WrapWalls = !_engine.WrapWalls;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnKeyDown(KeyboardEventArgs e)
    {
        lock (_lockObj)
        {
            switch (e.Code)
            {
                case "ArrowUp":
                case "KeyW": _engine.TurnUp(); break;
                case "ArrowDown":
                case "KeyS": _engine.TurnDown(); break;
                case "ArrowLeft":
                case "KeyA": _engine.TurnLeft(); break;
                case "ArrowRight":
                case "KeyD": _engine.TurnRight(); break;
                case "Space":
                    if (_engine.IsGameOver)
                    {
                        var w = _engine.WrapWalls;
                        _engine.Reset();
                        _engine.WrapWalls = w;
                    }
                    else
                    {
                        _engine.Resume();
                    }
                    break;
                case "KeyP":
                    if (!_engine.IsGameOver) _engine.TogglePause();
                    break;
            }
        }
        _recordSavedThisGame = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync() => await StopLoopAsync();
}

@{
    var s = Snapshot;
}

<div class="snake-page">
    <div class="snake-layout">

        <aside class="records-panel">
            <h3>Top 10</h3>

            <table class="records-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Spieler</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody>
                    @if (_records.Count == 0)
                    {
                        <tr>
                            <td colspan="3" class="records-empty">Noch keine Eintr√§ge</td>
                        </tr>
                    }
                    else
                    {
                        @for (int i = 0; i < _records.Count; i++)
                        {
                            var r = _records[i];
                            <tr>
                                <td>@(i + 1)</td>
                                <td>@r.UserName</td>
                                <td>@r.Score</td>
                            </tr>
                        }
                    }
                </tbody>
            </table>
        </aside>

        <main class="snake-board" role="application" aria-label="Snake board">
            <div class="board-grid"
                 @ref="_gridRef"
                 tabindex="0"
                 @onkeydown="OnKeyDown"
                 @onkeydown:preventDefault
                 @onkeydown:stopPropagation
                 style="grid-template-columns: repeat(@SnakeEngine.Width, 1fr);
                        grid-template-rows:    repeat(@SnakeEngine.Height, 1fr);">
                @for (var y = 0; y < SnakeEngine.Height; y++)
                {
                    for (var x = 0; x < SnakeEngine.Width; x++)
                    {
                        var cellClass = GetCellClasses(x, y, s);
                        <div class="@cellClass" aria-hidden="true"></div>
                    }
                }
            </div>
        </main>

        <aside class="snake-hud">
            <div class="hud-row">
                <span><strong>Score:</strong> @s.Score</span>
                <span><strong>High Score:</strong> @s.HighScore</span>
                <span><strong>Speed:</strong> @Math.Round(s.TickInterval.TotalMilliseconds) ms</span>
                <span><strong>Status:</strong> @GetStatusText(s)</span>
                <span><strong>Wrap:</strong> @(s.WrapWalls ? "On" : "Off")</span>
            </div>
            <div class="hud-row controls">
                <button class="btn" @onclick="TogglePause">@GetPauseButtonLabel(s)</button>
                <button class="btn" @onclick="ResetGame">Reset</button>
                <button class="btn" @onclick="ToggleWrap">@GetWrapButtonLabel(s)</button>
                <button class="btn" @onclick="ToggleAuto">@(_autoMode ? "Auto AUS" : "Auto AN")</button>

            </div>
        </aside>

    </div>
</div>
