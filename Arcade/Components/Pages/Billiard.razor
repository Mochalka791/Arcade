@page "/billiard"
@inject IJSRuntime JS
@implements IAsyncDisposable
@using Microsoft.JSInterop
@using System
@using System.Threading.Tasks

<PageTitle>Billiard</PageTitle>

<section class="billiard-page">
    <header class="billiard-header">
        <div>
            <h1>Billiard</h1>
            <p>Visiere die Objektkugeln an, kontrolliere den Stoß und versenke alle Kugeln so effizient wie möglich.</p>
        </div>
        <div class="billiard-stats">
            <div>
                <span>Kugeln übrig</span>
                <strong>@_remainingBalls</strong>
            </div>
            <div>
                <span>Stöße</span>
                <strong>@_shots</strong>
            </div>
        </div>
    </header>

    <div class="billiard-table">
        <canvas width="720" height="360" @ref="_canvasRef"></canvas>
        @if (_victory)
        {
            <div class="billiard-message">
                <h2>Alle Kugeln versenkt!</h2>
                <p>Perfekt gespielt – versuche es noch schneller.</p>
            </div>
        }
    </div>

    <div class="billiard-controls">
        <label>
            <span>Winkel</span>
            <input type="range" min="0" max="360" step="1" @bind-value="Angle" @bind-value:event="oninput" />
            <span class="value">@Angle.ToString("F0")°</span>
        </label>
        <label>
            <span>Kraft</span>
            <input type="range" min="10" max="100" step="1" @bind-value="Power" @bind-value:event="oninput" />
            <span class="value">@Power.ToString("F0")%</span>
        </label>
        <div class="buttons">
            <button class="arcade-btn" @onclick="ShootAsync" disabled="@(!_canShoot)">Stoß</button>
            <button class="arcade-btn secondary" @onclick="ResetAsync">Neu aufstellen</button>
        </div>
    </div>

    <p class="billiard-tip">Justiere Winkel und Kraft, bis die Leuchtlinie perfekt sitzt – sie zeigt dir den ersten Treffer und die Stoßintensität.</p>
</section>

@code {
    private ElementReference _canvasRef;
    private DotNetObjectReference<Billiard>? _objRef;
    private IJSObjectReference? _module;
    private double _angle = 15;
    private double _power = 55;
    private int _remainingBalls = 3;
    private int _shots;
    private bool _victory;
    private bool _canShoot = true;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _module = await JS.InvokeAsync<IJSObjectReference>("import", "./scripts/billiard.js");
            _objRef = DotNetObjectReference.Create(this);
            await _module.InvokeVoidAsync("init", _canvasRef, _objRef, _angle, _power);
            await UpdateAimAsync();
        }
    }

    private async Task ShootAsync()
    {
        if (!_canShoot || _module is null)
        {
            return;
        }

        _canShoot = false;
        StateHasChanged();
        await _module.InvokeVoidAsync("shoot", _canvasRef, _angle, _power);
    }

    private async Task ResetAsync()
    {
        if (_module is null)
        {
            return;
        }

        await _module.InvokeVoidAsync("reset", _canvasRef);
        Angle = 15;
        Power = 55;
        await UpdateAimAsync();
        _victory = false;
        _remainingBalls = 3;
        _shots = 0;
        _canShoot = true;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task UpdateStatus(int remaining, int shots, bool victory, bool ready)
    {
        _remainingBalls = remaining;
        _shots = shots;
        _victory = victory;
        _canShoot = ready && !victory;
        await InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (_module is not null)
        {
            try
            {
                await _module.InvokeVoidAsync("dispose", _canvasRef);
            }
            catch
            {
            }
            await _module.DisposeAsync();
            _module = null;
        }

        if (_objRef is not null)
        {
            _objRef.Dispose();
            _objRef = null;
        }
    }

    private double Angle
    {
        get => _angle;
        set
        {
            if (Math.Abs(_angle - value) < 0.01)
            {
                return;
            }

            _angle = value;
            _ = UpdateAimAsync();
        }
    }

    private double Power
    {
        get => _power;
        set
        {
            if (Math.Abs(_power - value) < 0.01)
            {
                return;
            }

            _power = value;
            _ = UpdateAimAsync();
        }
    }

    private Task UpdateAimAsync()
    {
        if (_module is null)
        {
            return Task.CompletedTask;
        }

        return _module.InvokeVoidAsync("updateAim", _canvasRef, _angle, _power).AsTask();
    }
}
