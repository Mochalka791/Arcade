@page "/tetris"
@implements IDisposable
@using Microsoft.AspNetCore.Components.Web
@using System.Linq
@using System.Collections.Generic
@using System.Threading.Tasks

<PageTitle>Tetris</PageTitle>

<section class="tetris-page">
    <header class="tetris-header">
        <div>
            <h1>Tetris</h1>
            <p>Bleib im Rhythmus, cleare Linien und steigere die Geschwindigkeit mit jedem Erfolg.</p>
        </div>
        <div class="tetris-actions">
            <button class="arcade-btn" @onclick="TogglePause" disabled="@_isGameOver">@(_isPaused ? "Fortsetzen" : "Pause")</button>
            <button class="arcade-btn" @onclick="ResetGameAsync">Neu starten</button>
            <button class="arcade-btn" @onclick="HardDropFromButton" disabled="@(_isPaused || _isGameOver)">Harddrop</button>
            <button class="arcade-btn secondary" @onclick="ToggleDebug">@(_showDebug ? "Debug aus" : "Debug an")</button>
        </div>
    </header>

    <div class="tetris-body">
        <div class="tetris-board" tabindex="0" role="application" @onkeydown="HandleKeyDown" @onkeydown:preventDefault="true"
             @onkeydown:stopPropagation="true" @onpointerdown="() => FocusBoard()" @ref="_boardRef">
            @for (var r = 0; r < BoardHeight; r++)
            {
                @for (var c = 0; c < BoardWidth; c++)
                {
                    var cell = GetCellState(r, c);
                    <div class="cell @cell.Class" style="background:@cell.Color"></div>
                }
            }
        </div>

        <aside class="tetris-side">
            <div class="panel">
                <h2>Punkte</h2>
                <p>@Score</p>
            </div>
            <div class="panel">
                <h2>Linien</h2>
                <p>@_linesCleared</p>
            </div>
            <div class="panel">
                <h2>Level</h2>
                <p>@_level</p>
            </div>
            <div class="panel next-piece">
                <h2>Nächstes Teil</h2>
                <div class="mini-grid">
                    @for (var r = 0; r < 4; r++)
                    {
                        @for (var c = 0; c < 4; c++)
                        {
                            var color = _nextPreview[r, c];
                            <div class="cell" style="background:@color"></div>
                        }
                    }
                </div>
            </div>
            <div class="panel controls">
                <h2>Steuerung</h2>
                <ul>
                    <li><span>← →</span> bewegen</li>
                    <li><span>↑ / W</span> rotieren</li>
                    <li><span>↓</span> schneller fallen</li>
                    <li><span>Leertaste</span> Harddrop</li>
                    <li><span>P</span> Pause</li>
                </ul>
            </div>
            @if (_showDebug)
            {
                <div class="panel debug">
                    <h2>Debug</h2>
                    <div class="debug-actions">
                        <button class="arcade-btn secondary" @onclick="() => AdjustScore(100)">+100 Punkte</button>
                        <button class="arcade-btn secondary" @onclick="ForceLineClear">Linie füllen</button>
                        <button class="arcade-btn secondary" @onclick="DropStep">Step</button>
                        <button class="arcade-btn secondary" @onclick="SpawnSpecific">I-Teil</button>
                    </div>
                </div>
            }
        </aside>
    </div>

    @if (_isGameOver)
    {
        <div class="tetris-overlay">
            <div class="overlay-card">
                <h2>Game Over</h2>
                <p>Du hast @Score Punkte erreicht.</p>
                <button class="arcade-btn" @onclick="ResetGameAsync">Noch eine Runde</button>
            </div>
        </div>
    }
</section>

@code {
    private const int BoardWidth = 10;
    private const int BoardHeight = 20;

    private readonly string?[,] _board = new string?[BoardHeight, BoardWidth];
    private TetrominoInstance? _currentPiece;
    private TetrominoDefinition? _nextPiece;
    private readonly Random _random = new();
    private System.Timers.Timer? _dropTimer;
    private ElementReference _boardRef;

    private int _linesCleared;
    private int _level = 1;
    private bool _isPaused;
    private bool _isGameOver;
    private bool _showDebug;
    private readonly string?[,] _nextPreview = new string?[4, 4];

    public int Score { get; set; }

    private static readonly TetrominoDefinition[] Definitions = new[]
    {
        TetrominoDefinition.FromMatrix("I", "#48d6ff", new[]
        {
            "....",
            "####",
            "....",
            "...."
        }),
        TetrominoDefinition.FromMatrix("O", "#ffe45c", new[]
        {
            ".##.",
            ".##.",
            "....",
            "...."
        }),
        TetrominoDefinition.FromMatrix("T", "#b77bff", new[]
        {
            ".#..",
            "###.",
            "....",
            "...."
        }),
        TetrominoDefinition.FromMatrix("S", "#64f2a9", new[]
        {
            ".##.",
            "##..",
            "....",
            "...."
        }),
        TetrominoDefinition.FromMatrix("Z", "#ff6f78", new[]
        {
            "##..",
            ".##.",
            "....",
            "...."
        }),
        TetrominoDefinition.FromMatrix("J", "#3da2ff", new[]
        {
            "#...",
            "###.",
            "....",
            "...."
        }),
        TetrominoDefinition.FromMatrix("L", "#ffb347", new[]
        {
            "..#.",
            "###.",
            "....",
            "...."
        })
    };

    public Tetris()
    {
        _dropTimer = new System.Timers.Timer(800);
        _dropTimer.AutoReset = true;
        _dropTimer.Elapsed += HandleTick;
    }

    protected override void OnInitialized()
    {
        _dropTimer?.Stop();
        StartGame();
        _dropTimer?.Start();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await FocusBoard();
        }
    }

    private void HandleTick(object? sender, System.Timers.ElapsedEventArgs e)
    {
        if (_isPaused || _isGameOver)
        {
            return;
        }

        _ = InvokeAsync(() =>
        {
            if (_isPaused || _isGameOver)
            {
                return;
            }

            StepDown();
        });
    }

    private void StartGame()
    {
        _dropTimer?.Stop();
        Array.Clear(_board, 0, _board.Length);
        Score = 0;
        _linesCleared = 0;
        _level = 1;
        _isPaused = false;
        _isGameOver = false;
        _nextPiece = GetRandomDefinition();
        SpawnPiece();
        UpdateTimerSpeed();
        BuildNextPreview();
        StateHasChanged();
    }

    private void SpawnPiece()
    {
        var definition = _nextPiece ?? GetRandomDefinition();
        _currentPiece = new TetrominoInstance(definition, rotation: 0, row: -2, col: 3);
        _nextPiece = GetRandomDefinition();
        BuildNextPreview();

        if (!IsValidPosition(_currentPiece.Definition, _currentPiece.Rotation, _currentPiece.Row, _currentPiece.Col))
        {
            _isGameOver = true;
            _dropTimer?.Stop();
        }
    }

    private TetrominoDefinition GetRandomDefinition() => Definitions[_random.Next(Definitions.Length)];

    private void StepDown()
    {
        if (_currentPiece is null)
        {
            return;
        }

        if (!TryMove(0, 1))
        {
            LockPiece();
        }

        StateHasChanged();
    }

    private bool TryMove(int deltaX, int deltaY)
    {
        if (_currentPiece is null)
        {
            return false;
        }

        var newRow = _currentPiece.Row + deltaY;
        var newCol = _currentPiece.Col + deltaX;

        if (!IsValidPosition(_currentPiece.Definition, _currentPiece.Rotation, newRow, newCol))
        {
            return false;
        }

        _currentPiece = _currentPiece with { Row = newRow, Col = newCol };
        return true;
    }

    private void LockPiece()
    {
        if (_currentPiece is null)
        {
            return;
        }

        foreach (var (row, col) in GetCells(_currentPiece.Definition, _currentPiece.Rotation, _currentPiece.Row, _currentPiece.Col))
        {
            if (row < 0)
            {
                continue;
            }

            _board[row, col] = _currentPiece.Definition.Color;
        }

        _currentPiece = null;
        ClearLines();
        SpawnPiece();
    }

    private void ClearLines()
    {
        var cleared = 0;

        for (var row = 0; row < BoardHeight; row++)
        {
            var full = true;
            for (var col = 0; col < BoardWidth; col++)
            {
                if (_board[row, col] is null)
                {
                    full = false;
                    break;
                }
            }

            if (!full)
            {
                continue;
            }

            cleared++;
            for (var r = row; r > 0; r--)
            {
                for (var c = 0; c < BoardWidth; c++)
                {
                    _board[r, c] = _board[r - 1, c];
                }
            }

            for (var c = 0; c < BoardWidth; c++)
            {
                _board[0, c] = null;
            }
        }

        if (cleared == 0)
        {
            return;
        }

        _linesCleared += cleared;
        Score += cleared switch
        {
            1 => 100,
            2 => 300,
            3 => 500,
            4 => 800,
            _ => 0
        };

        UpdateLevel();
    }

    private void UpdateLevel()
    {
        var newLevel = Math.Clamp(1 + _linesCleared / 10, 1, 15);
        if (newLevel != _level)
        {
            _level = newLevel;
        }

        UpdateTimerSpeed();
    }

    private void UpdateTimerSpeed()
    {
        if (_dropTimer is null)
        {
            return;
        }

        var interval = Math.Max(110, 800 - (_level - 1) * 60);
        _dropTimer.Interval = interval;
        if (!_isPaused && !_isGameOver && !_dropTimer.Enabled)
        {
            _dropTimer.Start();
        }
    }

    private void HardDropFromButton()
    {
        HardDrop();
        _ = FocusBoard();
    }

    private void HardDrop()
    {
        if (_currentPiece is null || _isPaused || _isGameOver)
        {
            return;
        }

        var rows = 0;
        while (TryMove(0, 1))
        {
            rows++;
        }

        if (rows > 0)
        {
            Score += rows * 2;
        }

        LockPiece();
        StateHasChanged();
    }

    private void TogglePause()
    {
        if (_isGameOver)
        {
            return;
        }

        _isPaused = !_isPaused;

        if (_dropTimer is not null)
        {
            _dropTimer.Enabled = !_isPaused;
        }

        _ = FocusBoard();
    }

    private async Task ResetGameAsync()
    {
        StartGame();
        _dropTimer?.Start();
        await FocusBoard();
    }

    private async Task FocusBoard()
    {
        try
        {
            await _boardRef.FocusAsync(preventScroll: true);
        }
        catch
        {
        }
    }

    private void ToggleDebug()
    {
        _showDebug = !_showDebug;
        StateHasChanged();
    }

    private void AdjustScore(int delta)
    {
        Score += delta;
        UpdateLevel();
        StateHasChanged();
    }

    private void ForceLineClear()
    {
        var row = BoardHeight - 1;
        for (var c = 0; c < BoardWidth; c++)
        {
            _board[row, c] = "#2f8bff";
        }

        ClearLines();
        StateHasChanged();
    }

    private void DropStep()
    {
        if (_isPaused || _isGameOver)
        {
            return;
        }

        StepDown();
    }

    private void SpawnSpecific()
    {
        _nextPiece = Definitions.First(d => d.Name == "I");
        if (_currentPiece is null)
        {
            SpawnPiece();
        }
        BuildNextPreview();
        StateHasChanged();
    }

    private void Rotate()
    {
        if (_currentPiece is null)
        {
            return;
        }

        var nextRotation = (_currentPiece.Rotation + 1) % _currentPiece.Definition.Rotations.Length;
        if (IsValidPosition(_currentPiece.Definition, nextRotation, _currentPiece.Row, _currentPiece.Col))
        {
            _currentPiece = _currentPiece with { Rotation = nextRotation };
        }
    }

    private void MoveHorizontal(int delta)
    {
        TryMove(delta, 0);
    }

    private void SoftDrop()
    {
        if (TryMove(0, 1))
        {
            Score += 1;
        }
        else
        {
            LockPiece();
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (_isGameOver)
        {
            if (e.Key == " " || e.Key == "Enter")
            {
                _ = ResetGameAsync();
            }
            return;
        }

        switch (e.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                MoveHorizontal(-1);
                break;
            case "ArrowRight":
            case "d":
            case "D":
                MoveHorizontal(1);
                break;
            case "ArrowDown":
            case "s":
            case "S":
                SoftDrop();
                break;
            case "ArrowUp":
            case "w":
            case "W":
                Rotate();
                break;
            case " ":
                HardDrop();
                break;
            case "p":
            case "P":
                TogglePause();
                break;
        }

        StateHasChanged();
    }

    private bool IsValidPosition(TetrominoDefinition definition, int rotation, int row, int col)
    {
        foreach (var (r, c) in GetCells(definition, rotation, row, col))
        {
            if (c < 0 || c >= BoardWidth)
            {
                return false;
            }

            if (r >= BoardHeight)
            {
                return false;
            }

            if (r < 0)
            {
                continue;
            }

            if (_board[r, c] is not null)
            {
                return false;
            }
        }

        return true;
    }

    private static IEnumerable<(int Row, int Col)> GetCells(TetrominoDefinition definition, int rotation, int row, int col)
    {
        foreach (var offset in definition.Rotations[rotation])
        {
            yield return (row + offset.Row, col + offset.Col);
        }
    }

    private CellState GetCellState(int row, int col)
    {
        if (_currentPiece is not null)
        {
            foreach (var (r, c) in GetCells(_currentPiece.Definition, _currentPiece.Rotation, _currentPiece.Row, _currentPiece.Col))
            {
                if (r == row && c == col)
                {
                    return new CellState("filled active", _currentPiece.Definition.Color);
                }
            }
        }

        var color = _board[row, col];
        if (color is not null)
        {
            return new CellState("filled", color);
        }

        return new CellState(string.Empty, "transparent");
    }

    private void BuildNextPreview()
    {
        for (var r = 0; r < 4; r++)
        {
            for (var c = 0; c < 4; c++)
            {
                _nextPreview[r, c] = "transparent";
            }
        }

        if (_nextPiece is null)
        {
            return;
        }

        foreach (var (r, c) in _nextPiece.Rotations[0])
        {
            if (r >= 0 && r < 4 && c >= 0 && c < 4)
            {
                _nextPreview[r, c] = _nextPiece.Color;
            }
        }
    }

    public void Dispose()
    {
        if (_dropTimer is not null)
        {
            _dropTimer.Elapsed -= HandleTick;
            _dropTimer.Dispose();
        }
    }

    private record TetrominoDefinition(string Name, string Color, (int Row, int Col)[][] Rotations)
    {
        public static TetrominoDefinition FromMatrix(string name, string color, string[] rows)
        {
            if (rows.Length != 4 || rows.Any(r => r.Length != 4))
            {
                throw new ArgumentException("Tetromino definition must be a 4x4 matrix.");
            }

            var rotations = new List<(int Row, int Col)[]>();
            var matrix = rows.Select(r => r.ToCharArray()).ToArray();

            for (var i = 0; i < 4; i++)
            {
                var cells = new List<(int Row, int Col)>();
                for (var r = 0; r < 4; r++)
                {
                    for (var c = 0; c < 4; c++)
                    {
                        if (matrix[r][c] == '#')
                        {
                            cells.Add((r, c));
                        }
                    }
                }

                rotations.Add(cells.ToArray());
                matrix = Rotate(matrix);
            }

            return new TetrominoDefinition(name, color, rotations.ToArray());
        }

        private static char[][] Rotate(char[][] input)
        {
            var size = input.Length;
            var rotated = new char[size][];
            for (var r = 0; r < size; r++)
            {
                rotated[r] = new char[size];
                for (var c = 0; c < size; c++)
                {
                    rotated[r][c] = input[size - c - 1][r];
                }
            }

            return rotated;
        }
    }

    private record TetrominoInstance(TetrominoDefinition Definition, int Rotation, int Row, int Col);

    private readonly record struct CellState(string Class, string Color);
}
